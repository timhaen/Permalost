<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vier Punkte Darstellung</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            background-color: rgb(20, 20, 20);
        }
    </style>
</head>
<body>
    <svg width="100%" height="100%"></svg>
    <script>
        // Set dimensions for SVG
        const width = window.innerWidth;
        const height = window.innerHeight;
        const svg = d3.select("svg").attr("width", width).attr("height", height);

        // Define the map projection
        const projection = d3.geoOrthographic()
            .translate([width / 2, 700])
            .scale(750)
            .rotate([0, -55, 0]) // Arctic center (Longitude, Latitude, Roll)
            .clipAngle(89);

        const path = d3.geoPath().projection(projection);

        // Load and draw the world map
        d3.json("countries/world.geojson").then(function (data) {
            const features = data.features;

            // Create gradient for atmosphere
            const gradient = svg.append("defs")
                .append("radialGradient")
                .attr("id", "atmosphere-gradient")
                .attr("cx", "50%")
                .attr("cy", "50%")
                .attr("r", "50%")
                .attr("fx", "50%")
                .attr("fy", "50%");

            gradient.append("stop")
                .attr("offset", "80%")
                .attr("stop-color", "rgb(200, 190, 150)");

            gradient.append("stop")
                .attr("offset", "100%")
                .attr("stop-color", "rgb(20, 20, 20)");

            // Draw atmosphere
            svg.append("circle")
                .attr("cx", width / 2)
                .attr("cy", 700)
                .attr("r", 800)
                .attr("fill", "url(#atmosphere-gradient)");

            // Draw the Earth
            svg.append("circle")
                .attr("cx", width / 2)
                .attr("cy", 700)
                .attr("r", 750)
                .attr("fill", "rgb(40, 40, 40)");

            // Draw land masses
            svg.selectAll("path")
                .data(features)
                .enter()
                .append("path")
                .attr("d", path)
                .style("fill", "rgb(60,60,60)")
                .style("stroke-width", 0.4)
                .style("stroke", "rgb(80,80,80)");

            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            // Load and draw permafrost data
            d3.csv("alt2003_200raster.csv").then(function (data) {
                data.forEach(function (d, i) {
                    d.lon = parseFloat(d.x);
                    d.lat = parseFloat(d.y);
                    d.value = parseFloat(d.value);
                    d.index = i;
                });

                // Find the min and max values in the dataset
                const minValue = d3.min(data, (d) => d.value);
                const maxValue = d3.max(data, (d) => d.value);
                console.log(minValue);
                console.log(maxValue);

                // Categorize values into 4 categories
                const categoryThresholds = d3.scaleQuantile()
                    .domain([minValue, maxValue])
                    .range([1, 2, 3, 4]);

                const r = 4;
                const opa = 1;
                const distanceInbetweenPoints = 9; // Distance between points within a group
                const distanceBetweenPointGroupsX = 15; // Distance between groups of points
                const distanceBetweenPointGroupsY = 50; // Distance between groups of points

                const drawnPoints = []; // Array to store already drawn points

                data.forEach((d) => {
                    if (d.index % 1 === 0) {
                        const category = categoryThresholds(d.value);
                        const coordinates = projection([d.lon, d.lat]);

                        // Check if there is already a point in the vicinity
                        const overlapping = drawnPoints.some((point) => {
                            const dx = coordinates[0] - point[0];
                            const dy = coordinates[1] - point[1];
                            return Math.abs(dx) < distanceBetweenPointGroupsX && Math.abs(dy) < distanceBetweenPointGroupsY;
                        });

                        if (!overlapping) {
                            // Draw the ellipses and rectangles for each category
                            if (category >= 1) {
                                svg.append("ellipse")
                                    .attr("cx", coordinates[0])
                                    .attr("cy", coordinates[1] + distanceInbetweenPoints)
                                    .attr("rx", r)
                                    .attr("ry", r)
                                    .attr("fill", "rgb(213,235,255)")
                                    .attr("opacity", opa);

                                svg.append("rect")
                                    .attr("x", coordinates[0] - 0.5)
                                    .attr("y", coordinates[1] - 2.5)
                                    .attr("width", 1)
                                    .attr("height", 5)
                                    .attr("fill", "rgb(255, 255, 255)");

                                svg.append("rect")
                                    .attr("x", coordinates[0] - 2.5)
                                    .attr("y", coordinates[1] - 0.5)
                                    .attr("width", 5)
                                    .attr("height", 1)
                                    .attr("fill", "rgb(255, 255, 255)");
                            }
                            if (category >= 2) {
                                svg.append("ellipse")
                                    .attr("cx", coordinates[0])
                                    .attr("cy", coordinates[1] + (2 * distanceInbetweenPoints))
                                    .attr("rx", r)
                                    .attr("ry", r)
                                    .attr("fill", "rgb(162,180,198)")
                                    .attr("opacity", opa);
                            }
                            if (category >= 3) {
                                svg.append("ellipse")
                                    .attr("cx", coordinates[0])
                                    .attr("cy", coordinates[1] + (3 * distanceInbetweenPoints))
                                    .attr("rx", r)
                                    .attr("ry", r)
                                    .attr("fill", "rgb(112,125,137)")
                                    .attr("opacity", opa);
                            }
                            if (category >= 4) {
                                svg.append("ellipse")
                                    .attr("cx", coordinates[0])
                                    .attr("cy", coordinates[1] + (4 * distanceInbetweenPoints))
                                    .attr("rx", r)
                                    .attr("ry", r)
                                    .attr("fill", "rgb(80,88,94)")
                                    .attr("opacity", opa);
                            }

                            // Store the coordinates of the drawn point
                            drawnPoints.push(coordinates);
                        }
                    }
                });
            });
        });
    </script>
</body>
</html>
